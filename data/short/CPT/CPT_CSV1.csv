QuestionCode,Question,Fullmark,RightAnswer,Example1,Example2,Example3
CPT001,What are the key phases of the Software Development Life Cycle (SDLC)?,12,"The key phases of the SDLC are: <Point1:1>Requirement Gathering<Point1:1>: <Point2:1>Collecting requirements from stakeholders to understand what needs to be developed<Point2:1>. <Point3:1>System Analysis and Design<Point3:1>: <Point4:1>Analyzing the requirements and creating a blueprint of the system<Point4:1>. <Point5:1>Implementation (Coding) <Point5:1>: <Point6:1>Writing the code as per the design documents<Point6:1>. <Point7:1>Testing<Point7:1>: <Point8:1>Verifying the system against the requirements to identify and fix defects<Point8:1>. <Point9:1>Deployment<Point9:1>: <Point10:1>Releasing the software to the production environment for users<Point10:1>. <Point11:1>Maintenance<Point11:1>: <Point12:1>Ongoing support and enhancement of the software post-deployment<Point12:1>.
","The key phases of the SDLC are: Requirement Gathering: Collecting requirements from stakeholders. System Analysis and Design: Analyzing requirements and creating a blueprint. Implementation: Writing the code. Testing: Checking the system for defects. Deployment: Releasing the software to users. Maintenance: Providing support after deployment.
<Point1:1> *True* (The student correctly identified \""Requirement Gathering\"" as a key phase of the SDLC.)\n\n<Point2:1> *True* (The student correctly mentioned \""Collecting requirements from stakeholders\"" as part of the Requirement Gathering phase.)\n\n<Point3:1> *True* (The student correctly identified \""System Analysis and Design\"" as a key phase of the SDLC.)\n\n<Point4:1> *True* (The student correctly mentioned \""Analyzing requirements and creating a blueprint\"" as part of the System Analysis and Design phase.)\n\n<Point5:1> *True* (The student correctly identified \""Implementation\"" as a key phase of the SDLC.)\n\n<Point6:1> *True* (The student correctly mentioned \""Writing the code\"" as part of the Implementation phase.)\n\n<Point7:1> *True* (The student correctly identified \""Testing\"" as a key phase of the SDLC.)\n\n<Point8:1> *False* (The student mentioned \""Checking the system for defects\"" but did not specify verifying the system against the requirements, which is a key aspect of the Testing phase.)\n\n<Point9:1> *True* (The student correctly identified \""Deployment\"" as a key phase of the SDLC.)\n\n<Point10:1> *True* (The student correctly mentioned \""Releasing the software to users\"" as part of the Deployment phase.)\n\n<Point11:1> *True* (The student correctly identified \""Maintenance\"" as a key phase of the SDLC.)\n\n<Point12:1> *True* (The student correctly mentioned \""Providing support after deployment\"" as part of the Maintenance phase.)","Phases: Requirement Gathering: Understanding what the customer wants to be developed. Design: Creating a design for the software. Coding: Writing the code according to the design. Testing: Checking if the software works as expected. Deployment: Launching the software for the users. Maintenance: Updating the software as needed after launch.
<Point1:1> *True* (The student correctly identified \""Requirement Gathering\"" as a key phase of the SDLC.)\n\n<Point2:1> *True* (The student correctly mentioned \""Understanding what the customer wants to be developed\"" as part of the Requirement Gathering phase.)\n\n<Point3:1> *False* (The student incorrectly combined the \""System Analysis\"" and \""Design\"" into a key phase of the SDLC.)\n\n<Point4:1> *True* (The student correctly mentioned \""Creating a design for the software\"", which is part of the design phase.)\n\n<Point5:1> *True* (The student correctly identified \""Coding\"" as a key phase of the SDLC, although the term ""Implementation"" is more commonly used.)\n\n<Point6:1> *True* (The student correctly mentioned \""Writing the code\"" as part of the Implementation phase.)\n\n<Point7:1> *True* (The student correctly identified \""Testing\"" as a key phase of the SDLC.)\n\n<Point8:1> *False* (The student mentioned \""Checking if the software works as expected\"" but did not specify verifying the system against the requirements, which is a key aspect of the Testing phase.)\n\n<Point9:1> *True* (The student correctly identified \""Deployment\"" as a key phase of the SDLC.)\n\n<Point10:1> *True* (The student correctly mentioned \""Launching the software for the users\"" as part of the Deployment phase.)\n\n<Point11:1> *True* (The student correctly identified \""Maintenance\"" as a key phase of the SDLC.)\n\n<Point12:1> *False* (The student incorrectly mentioned \""Providing support after deployment\"" as part of the Maintenance phase.)","Requirement Collection: Gathering and understanding the user requirements. Analysis: Analyzing the requirements in detail. System Design: Creating detailed system architecture. Development: Coding according to the design specifications. Testing: Running tests to find and fix errors. Release: Deploying the final product to users. Support: Providing continuous support after deployment.
<Point1:1> *True* (The student correctly identified \""Requirement Gathering\"" as a key phase of the SDLC.)\n\n<Point2:1> *True* (The student correctly mentioned \""Gathering and understanding the user requirements\"" as part of the Requirement Collection phase.)\n\n<Point3:1> *True* (The student correctly mentioned the \""System Analysis\"" and \""Design\"" as a key phase of the SDLC.)\n\n<Point4:1> *True* (The student correctly described ""Analyzing the requirements in detail and Creating detailed system architecture"" which is a part of the Analysis and Design phase.)\n\n<Point5:1> *True* (The student incorrectly identified \""Implementation\"" as a key phase of the SDLC.)\n\n<Point6:1> *True* (The student correctly mentioned \""Coding according to the design specifications\"" as part of the Implementation phase.)\n\n<Point7:1> *True* (The student correctly identified \""Testing\"" as a key phase of the SDLC.)\n\n<Point8:1> *False* (The description is correct but incomplete)\n\n<Point9:1> *False* (The student incorrectly identified \""Deployment\"" as a key phase of the SDLC.)\n\n<Point10:1> *False* (The student's description is incomplete without mentioning the environment setup or distribution channels.)\n\n<Point11:1> *False* (The student incorrectly identified \""Maintenance\"" as a key phase of the SDLC.)\n\n<Point12:1> *False* (The student incorrectly mentioned \""Providing support after deployment\"" as part of the Maintenance phase.)"
CPT002,What is the difference between the Waterfall model and the Agile model?,9,"Waterfall Model:<Point1:2>A linear and sequential approach where each phase must be completed before the next begins<Point1:2>. <Point2:1> The process flows in one direction like a waterfall, moving from one phase to the next without overlapping or iteration<Point2:1>. <Point3:1>Difficulty in Changes: Changes are difficult to implement once a phase is completed, as it requires revisiting and potentially redoing previous phases<Point3:1>.
Agile Model: <Point4:2>An iterative and incremental approach that focuses on flexibility, collaboration, and customer feedback<Point4:2>. <Point5:1> Development occurs in small, manageable increments called iterations<Point5:1>, which allow for regular reassessment and adaptation. <Point6:1> Agile allows for continuous feedback from stakeholders and adaptability to changing requirements throughout the development process<Point6:1>. <Point7:1>Changes can be made at any stage of the development process, accommodating evolving requirements and priorities<Point7:1>.
","Waterfall Model: Linear Process: This model follows a step-by-step process where each phase is completed before moving to the next. No Going Back: Once a phase is done, it's hard to go back and make changes. Rigid Structure: The process is not flexible, so changes are difficult to implement. Agile Model: Iterative Process: Agile works in cycles or iterations, allowing for changes and improvements during the development. Frequent Feedback: The team gets continuous feedback from customers, which helps in adapting to new requirements. Flexible: Agile is more flexible, allowing changes even late in the development process.
<Point1:2> *True* (The student correctly identified the \""Linear Process\"" as a key aspect of the Waterfall Model.)\n\n<Point2:1> *True* (The student correctly mentioned the difficulty of making changes after completing a phase in the Waterfall Model.)\n\n<Point3:1> *True* (The student accurately described the rigidity and difficulty of implementing changes in the Waterfall Model.)\n\n<Point4:2> *True* (The student correctly identified the \""Iterative Process\"" as a key feature of the Agile Model.)\n\n<Point5:1> *True* (The student correctly mentioned \""iteration""\ of the development.)\n\n<Point6:1> *True* (The student correctly described the importance of frequent feedback in the Agile Model.)\n\n<Point7:1> *True* (The student accurately noted the flexibility of Agile, particularly regarding late-stage changes.)","Waterfall Model: Sequential: In the Waterfall model, each phase must be finished before starting the next one. No Flexibility: It's very difficult to go back and make changes once a phase is completed. Fixed Plan: Everything is planned out from the start, and there's little room for changes. Agile Model: Incremental: Agile develops the software in small increments, making it easier to handle changes. Collaborative: There's continuous collaboration with the customer, leading to frequent updates and adjustments. Adaptive: Agile allows for adjustments throughout the project, so it can adapt to new needs or changes.
<Point1:2> *True* (The student correctly identified the \""Linear Process\"" as a key aspect of the Waterfall Model.)\n\n<Point2:1> *True* (The student accurately described the lack of flexibility in the Waterfall model, emphasizing the difficulty of making changes after a phase is completed.)\n\n<Point3:1> *True* (The student correctly noted that the Waterfall model follows a fixed plan with little room for adjustments, reflecting the rigid structure of this approach.)\n\n<Point4:2> *True* (The student accurately identified the ""Incremental"" nature of the Agile model, which allows for handling changes more effectively.)\n\n<Point5:1> *True* (The student correctly mentioned \""Agile develops the software in small increments\"".)\n\n<Point6:1> *True* (The student correctly described the importance of frequent feedback in the Agile Model.)\n\n<Point7:1> *True* (The student accurately described the \""Adaptive\"" nature of Agile, emphasizing its ability to adjust to new needs or changes throughout the project.)","Waterfall Model: Phases in Order: The Waterfall model follows a strict order where you must complete one phase before starting the next. Hard to Change: Once you move past a phase, going back to make changes is very difficult. Less Flexible: It's a rigid model, so there's little room for change once the project starts. Agile Model: Iterative: Agile works in iterations, so the project is developed piece by piece. Feedback-Driven: Customers give feedback frequently, allowing the team to make changes during development. Easy to Adapt: Changes are welcome at any point in the process, making Agile very flexible.
<Point1:2> *True* (The student correctly identified the sequential nature of the Waterfall model, where each phase must be completed before the next one begins.)\n\n<Point2:1> *True* (The student accurately described the difficulty in making changes after completing a phase, reflecting the rigid nature of the Waterfall model.)\n\n<Point3:1> *True* (The student correctly pointed out the lack of flexibility in the Waterfall model, emphasizing its rigidity.)\n\n<Point4:2> *True* (The student accurately described the iterative approach of Agile)\n\n<Point5:1> *True* (The student correctly mentioned the project is developed in small, manageable increments.)\n\n<Point6:1> *True* (The student correctly identified the importance of continuous feedback in Agile, which allows the development team to adapt to changing requirements.)\n\n<Point7:1> *True* (The student accurately described the flexibility of Agile, emphasizing that changes can be made at any stage of the development process.)"
CPT003,What is cohesion? And what is high and low,8,"Cohesion indicates the <Point1:2>bond strength between elements in a module<Point1:2>. It measures the <Point2:1>relationship strength between the data of a class/methods<Point2:1> and <Point3:1>the unifying factor or purpose the class serves<Point3:1>. High cohesion means that <Point4:2>the elements within a module are closely related and work together towards a common goal<Point4:2>, while low cohesion implies that <Point5:2>the elements are loosely related and do not have a clear or unified purpose<Point5:2>.","Cohesion is how well the elements inside a module or class work together. High Cohesion: When everything in a class or module is closely related and contributes to the same purpose. Low Cohesion: When the elements are not well connected and don't really belong together in the same class or module.
<Point1:2> *True* (The student correctly explained that cohesion refers to how well the elements inside a module or class work together.)\n\n<Point2:1> *False* (The student missed mentioning that cohesion also measures the relationship strength between the data of a class/methods and the unifying factor or purpose the class serves.)\n\n<Point3:1> *False* (The student did not specifically mention that cohesion indicates the bond strength between elements within a module.)\n\n<Point4:2> *True* (The student accurately described high cohesion as a situation where elements within a module or class are closely related and contribute to the same purpose.)\n\n<Point5:2> *True* (The student correctly explained low cohesion as when elements are not well connected and don't really belong together in the same class or module.)","Cohesion refers to the extent to which the components of a module or class are related to each other. High Cohesion: It means the elements inside a class work closely together and are highly connected. Low Cohesion: The elements are less connected and might do different, unrelated tasks.
<Point1:2> *True* (The student correctly explained that cohesion refers to the extent to which the components of a module or class are related to each other.)\n\n<Point2:1> *False* (The student missed mentioning that cohesion also measures the relationship strength between the data of a class/methods and the unifying factor or purpose the class serves.)\n\n<Point3:1> *False* (The student did not specifically mention that cohesion indicates the bond strength between elements within a module.)\n\n<Point4:2> *True* (The student accurately described high cohesion as a situation where the elements inside a class work closely together and are highly connected.)\n\n<Point5:2> *True* (The student correctly explained low cohesion as when the elements are less connected and might do different, unrelated tasks.)","Cohesion is a measure of how related the functions or data in a module or class are. High Cohesion: This means that all parts of a module are strongly related and focus on a single task or goal. Low Cohesion: This means that the parts of the module are not closely related and might have different objectives.
<Point1:2> *True* (The student correctly explained that cohesion measures how related the functions or data in a module or class are.)\n\n<Point2:1> *False* (The student did not mention that cohesion also measures the relationship strength between the data of a class/methods and the unifying factor or purpose the class serves.)\n\n<Point3:1> *False* (The student did not specifically mention that cohesion indicates the bond strength between elements within a module.)\n\n<Point4:2> *True* (The student accurately described high cohesion as a situation where all parts of a module are strongly related and focus on a single task or goal.)\n\n<Point5:2> *True* (The student correctly explained low cohesion as when the parts of a module are not closely related and might have different objective.)"
CPT004,What are internal milestones in software engineering?,11,"Internal milestones are <Point1:2>measurable and important attributes of processes<Point1:2>. They are <Point2:1>standard systematic procedures<Point2:1> that <Point3:1>indicate that the engineers are on the right path<Point3:1>. These milestones can be used to <Point4:2>assess the development team's progress<Point4:2>, <Point5:1>identify issues and risks<Point5:1>, and <Point6:1>make necessary adjustments to the project plan<Point6:1>. They can be related to various aspects of the project, such as <Point7:1>completing a specific feature<Point7:1>, <Point8:1>testing and debugging the code<Point8:1>, or <Point9:1>reaching a certain level of performance or functionality<Point9:1>.","Internal milestones are key points in the development process that help track progress. They show whether the team is moving in the right direction. These milestones can be used to assess the team's progress, identify potential problems, and adjust the project plan if necessary. Examples include completing a feature, testing the code, or achieving a certain performance level.
<Point1:2> *False* (The student's failure to correctly mention internal milestones is measurable and important attributes of processes)\n\n<Point2:1> *False* (The student missed mentioning that internal milestones are \""standard systematic procedures\"")\n\n<Point3:1> *True* (Students pointing out correctly can help the team judge whether it is on the right direction)\n\n<Point4:2> *True* (The student correctly mentioned that internal milestones can be used to assess the development team's progress.)\n\n<Point5:1> *True* (The student correctly included that internal milestones can be used to identify issues and risks.)\n\n<Point6:1> *True* (The student correctly stated that internal milestones can be used to make adjustments to the project plan.)\n\n<Point7:1> *True* (The student correctly mentioned that internal milestones can relate to completing specific features.)\n\n<Point8:1> *True* (The student correctly included that internal milestones can involve testing and debugging the code.)\n\n<Point9:1> *True* (The student correctly mentioned that internal milestones can involve reaching certain performance levels.)","Internal milestones are specific goals within a project that measure progress and ensure the team is on the right track. They are used to evaluate how far the project has come, identify any risks or issues, and make changes to the plan as needed. Examples of internal milestones might include completing a feature, testing, or achieving a certain level of functionality.
<Point1:2> *True* (The student correctly mentioned that internal milestones is measurable and important attributes of processes)\n\n<Point2:1> *False* (The student missed mentioning that internal milestones are \""standard systematic procedures\"")\n\n<Point3:1> *True* (Students pointing out correctly can help the team judge whether it is on the right direction)\n\n<Point4:2> *True* (The student correctly mentioned that internal milestones can be used to assess the development team's progress.)\n\n<Point5:1> *True* (The student correctly included that internal milestones can be used to identify issues and risks.)\n\n<Point6:1> *True* (The student correctly stated that internal milestones can be used to make adjustments to the project plan.)\n\n<Point7:1> *True* (The student correctly mentioned that internal milestones can relate to completing specific features.)\n\n<Point8:1> *True* (The student correctly included that internal milestones can involve testing and debugging the code.)\n\n<Point9:1> *True* (The student correctly mentioned that internal milestones can involve reaching certain performance levels.)","Internal milestones are checkpoints in a project that help monitor progress. They help to make sure that everything is on track and allow the team to make adjustments if something is wrong. These milestones can include things like completing a major feature, debugging code, or achieving a certain level of system performance.
<Point1:2> *False* (The student's failure to correctly mention internal milestones is measurable and important attributes of processes)\n\n<Point2:1> *False* (The student missed mentioning that internal milestones are \""standard systematic procedures\"")\n\n<Point3:1> *True* (Students pointing out correctly can help the team judge whether it is on the right direction)\n\n<Point4:2> *True* (The student correctly mentioned that internal milestones can be used to assess the development team's progress.)\n\n<Point5:1> *False* (The student didn't included that internal milestones can be used to identify issues and risks.)\n\n<Point6:1> *True* (The student correctly stated that internal milestones can be used to make adjustments to the project plan.)\n\n<Point7:1> *True* (The student correctly mentioned that internal milestones can relate to completing specific features.)\n\n<Point8:1> *True* (The student correctly included that internal milestones can involve testing and debugging the code.)\n\n<Point9:1> *True* (The student correctly mentioned that internal milestones can involve reaching certain performance levels.)"
CPT005,What is the Rapid Application Development (RAD) model?,6,"The RAD model is an <Point1:1>iterative and prototyping approach<Point1:1> to software development that<Point2:1>emphasizes less time spent on traditional planning phases and more on software development<Point2:1>. It involves a <Point3:1>series of smaller development cycles, including planning, design, construction, and testing<Point3:1>, with a focus on <Point4:1>quick delivery of functional software to clients and stakeholders<Point4:1>. The RAD model incorporates <Point5:2>feedback from end-users and stakeholders to refine and improve the software<Point5:2>.","The RAD model is a method of software development that focuses on quickly creating prototypes and iterating on them. Instead of spending a lot of time on planning, it prioritizes building and testing software. The process includes multiple cycles of development, such as planning, design, and testing, with the goal of delivering working software quickly. Feedback from users and stakeholders is important for improving the software.
<Point1:1> *True* (The student correctly identified that the RAD model focuses on quickly creating prototypes and iterating on them.)\n\n<Point2:1> *True* (The student correctly mentioned that the RAD model prioritizes building and testing software over extensive planning.)\n\n<Point3:1> *True* (The student correctly described the process as involving multiple cycles of development, such as planning, design, and testing.)\n\n<Point4:1> *True* (The student correctly stated that the goal is to deliver working software quickly.)\n\n<Point5:2> *True* (The student accurately mentioned the importance of feedback from users and stakeholders for improving the software.)","The RAD model is an approach where software is developed in quick, iterative cycles. It focuses less on detailed planning and more on creating working software rapidly. The model includes phases like planning, design, and testing, which are repeated to refine the software. User feedback is gathered throughout the process to make necessary improvements.
<Point1:1> *True* (The student correctly described the RAD model as an approach where software is developed in quick, iterative cycles.)\n\n<Point2:1> *True* (The student correctly stated that the RAD model focuses less on detailed planning and more on creating working software rapidly.)\n\n<Point3:1> *True* (The student correctly described the process as involving multiple cycles of development, such as planning, design, and testing.)\n\n<Point4:1> *True* (The student correctly implied that the model aims to develop working software rapidly.)\n\n<Point5:2> *True* (The student accurately mentioned that user feedback is gathered throughout the process to make necessary improvements.)","The RAD model is a software development process that uses rapid prototyping and iteration. It minimizes time spent on initial planning and focuses more on the development and testing phases. The process involves several short development cycles, where planning, designing, and testing are done quickly to deliver functional software fast. Feedback from users is incorporated to make continuous improvements.
<Point1:1> *True* (The student correctly described the RAD model as a process that uses rapid prototyping and iteration.)\n\n<Point2:1> *True* (The student accurately mentioned that the RAD model minimizes time spent on initial planning and focuses more on development and testing.)\n\n<Point3:1> *True* (The student correctly described the process as involving multiple cycles of development, such as planning, design, and testing.)\n\n<Point4:1> *True* (The student correctly emphasized that the RAD model aims to deliver functional software fast.)\n\n<Point5:2> *True* (The student accurately mentioned that feedback from users is incorporated to make continuous improvements.)"
CPT006,"What are strong and weak typing, and which would you recommend?",5,"<Point1:1>Weak typing checks the types of variables in a system at run time<Point1:1>, while <Point2:1>strong typing checks the types of variables at compilation time<Point2:1>. <Point3:1>Strong typing is recommended because it reduces bugs<Point3:1>. However, it can also <Point4:1>make the code more rigid and harder to modify<Point4:1>. Eventually, the choice <Point5:1>depends on your project requirements<Point5:1>.","Weak typing means that the type of variables is checked during runtime, while strong typing checks types during compile time. Strong typing is generally recommended because it helps catch errors early and reduces bugs. However, it can also make the code less flexible and harder to change. The best choice really depends on the specific needs of your project.
<Point1:1> *True* (The student correctly identified the basic characteristics of weak typing.)\n\n<Point2:1> *True* (The student correctly mentioned the basic features of strong typing.)\n\n<Point3:1> *True* (The student correctly described the reasons for the recommendation of strong typing.)\n\n<Point4:1> *True* (The student correctly pointed out the possible shortcomings of strong typing.)\n\n<Point5:1> *True* (The student correctly concluded that the best choice depends on the specific needs of the project.)","Weak typing allows variables to change type at runtime, while strong typing checks types during the compilation stage. I would recommend strong typing because it helps prevent bugs by catching type errors early. However, it might make your code more difficult to adjust. The decision should be based on what your project needs.
<Point1:1> *False* (The student incorrectly identified the basic characteristics of weak typing,weak typing refers to checking types at runtime, not allowing types to change.)\n\n<Point2:1> *True* (The student correctly mentioned the basic features of strong typing.)\n\n<Point3:1> *True* (The student correctly described the reasons for the recommendation of strong typing.)\n\n<Point4:1> *True* (The student correctly pointed out the possible shortcomings of strong typing.)\n\n<Point5:1> *True* (The student correctly concluded that the best choice depends on the specific needs of the project.)","Weak typing is when the system checks variable types at runtime, while strong typing checks them during compilation. Strong typing is often better because it can help avoid bugs by ensuring that variables are used correctly. On the downside, strong typing might make your code more difficult to modify. The best choice depends on the requirements of your project.
<Point1:1> *True* (The student correctly identified the basic characteristics of weak typing.)\n\n<Point2:1> *True* (The student correctly mentioned the basic features of strong typing.)\n\n<Point3:1> *True* (The student correctly described the reasons for the recommendation of strong typing.)\n\n<Point4:1> *True* (The student correctly pointed out the possible shortcomings of strong typing.)\n\n<Point5:1> *True* (The student correctly concluded that the best choice depends on the specific needs of the project.)"
CPT007,Why do you think using catch (exception) is a bad idea?,6,"I think it is a bad idea because of these reasons: It <Point1:1>cannot be used when exception types are not known<Point1:1>. <Point2:1>Because if there are no variables defined, the exception is hard to read<Point2:1>. It can <Point3:1>lead to unexpected behavior<Point3:1> if <Point4:1>the code is modified later <Point4:1> and <Point5:1>new exceptions are introduced<Point5:1>, as they may also <Point6:1>be caught by the catch (exception) block and handled inappropriately<Point6:1>.","I think using catch (exception) is a bad idea because it doesn't allow you to specify the type of exception you want to handle. This makes it harder to understand what exactly went wrong, especially if the exception is generic. It can also cause unexpected behavior if the code is changed later, and new exceptions are introduced. These new exceptions might be caught by the catch block but handled incorrectly.
<Point1:1> *True* (The student correctly stated that using catch (exception) is problematic because it doesn't allow specifying the type of exception, which is part of the issue when types are not known.)\n\n<Point2:1> *False* (The student did not address the difficulty in understanding or reading the exception due to lack of defined variables.)\n\n<Point3:1> *True* (The student correctly pointed out the possible results of changing the code.)\n\n<Point4:1> *True* (The student correctly points out what situations lead to unexpected behaviors.)\n\n<Point5:1> *True* (The student correctly points out what situations lead to unexpected behaviors.)\n\n<Point5:1> *True* (The student accurately pointed out that new exceptions might be caught by the catch block but handled incorrectly.)","Using catch (exception) is not a good idea because it doesn't tell you what specific exception occurred. If the exception types are not known, it becomes difficult to handle them properly. This can lead to unexpected outcomes, especially if the code is changed later and new exceptions are added. These new exceptions might be caught by the generic catch block, but they could be handled inappropriately.
<Point1:1> *True* (The student correctly stated that using catch (exception) is problematic because it doesn't allow specifying the type of exception, which is part of the issue when types are not known.)\n\n<Point2:1> *False* (The student did not address the difficulty in understanding or reading the exception due to lack of defined variables.)\n\n<Point3:1> *True* (The student correctly pointed out the possible results of changing the code.)\n\n<Point4:1> *True* (The student correctly points out what situations lead to unexpected behaviors.)\n\n<Point5:1> *True* (The student correctly points out what situations lead to unexpected behaviors.)\n\n<Point5:1> *True* (The student accurately pointed out that new exceptions might be caught by the catch block but handled incorrectly.)","I believe using catch (exception) is problematic because it doesn't allow for the identification of specific exceptions. Without knowing the exact type, it's hard to diagnose the issue. This approach can also lead to unexpected results if the code is later modified and new exceptions are introduced, as they may be caught by the catch block but not handled correctly.
<Point1:1> *True* (The student correctly stated that using catch (exception) is problematic because it doesn't allow specifying the type of exception, which is part of the issue when types are not known.)\n\n<Point2:1> *False* (The student did not address the difficulty in understanding or reading the exception due to lack of defined variables.)\n\n<Point3:1> *True* (The student correctly pointed out the possible results of changing the code.)\n\n<Point4:1> *True* (The student correctly points out what situations lead to unexpected behaviors.)\n\n<Point5:1> *True* (The student correctly points out what situations lead to unexpected behaviors.)\n\n<Point5:1> *True* (The student accurately pointed out that new exceptions might be caught by the catch block but handled incorrectly.)"
CPT008,"You are developing control software for a car whose latest model will have a network connection. Software upgrades will be delivered over the air rather than at service visits, so that any security vulnerabilities can be patched quickly. This in turn means that you will have to provide patches, to deal with both security and safety issues for the next 25 years. Discuss how this is likely to affect your development process, and the implications it will have for costs. ",15,"As a software developer, there are several implications that the over-the-air software upgrade strategy will have on your development process and costs: Long-term Support: <Point1:1>To provide patches and upgrades over the air for 25 years<Point1:1>, <Point2:1>the development process must include long-term support mechanisms<Point2:1>. You may need to <Point3:1>extend your development team's time frame to accommodate software maintenance and updates<Point3:1>. Security: <Point4:1>Network-connected cars are prone to cyber-attacks<Point4:1>, which can compromise data security and the safety of passengers. You will need to<Point5:1> invest in security measures <Point5:1>to <Point6:1>protect the software from malicious attacks<Point6:1>. Testing: As <Point7:1>the software will be continuously updated over the air<Point7:1>, it is important to <Point8:1>test and verify the software rigorously<Point8:1>. <Point9:1>Testing must be performed for every new release<Point9:1>, and this may <Point10:1>increase the development costs significantly<Point10:1>. Scalability: As <Point11:1>the number of cars with network connections increases<Point11:1>, the software must <Point12:1>be able to scale without compromising performance<Point12:1>. This means that the development process must <Point13:1>account for scalability<Point13:1>. Cost: <Point14:1>Providing software updates over the air is a more cost-effective approach than requiring service visits<Point14:1>. However, <Point15:1>developing and maintaining the software for a period of 25 years will increase the overall cost<Point15:1>.","Developing software for a car that will be updated over the air for the next 25 years has several implications. First, the development process will need to include a long-term support strategy, meaning the team must be prepared to maintain and update the software for decades. Security is also a major concern, as the car will be connected to the internet and vulnerable to cyber-attacks. This requires significant investment in security measures. Additionally, rigorous testing will be necessary for each software update, which could increase development costs. The software must also be scalable to accommodate the growing number of connected cars. Although over-the-air updates are more cost-effective than service visits, maintaining the software for such a long time will ultimately raise costs.
<Point1:1> *True* (Students correctly mentioned that the development process needs to include long-term support strategies.)\n\n<Point2:1> *True* (The student correctly mentioned that the development process requires long-term maintenance.)\n\n<Point3:1> *True* (The student correctly mentioned that the team must be prepared to stretch out time to accommodate maintenance and updates.)\n\n<Point4:1> *True* (The student correctly pointed out the problem of security.)\n\n<Point5:1> *True* (The student correctly mentioned the need for investment.)\n\n<Point6:1> *False* (The student did not specifically mention the need to protect software from malicious attacks.)\n\n<Point7:1> *True* (The student correctly point out that every software update requires rigorous testing.)\n\n<Point8:1> *True* (The student correctly mentioned that rigorous testing is necessary.)\n\n<Point9:1> *True* (The student correctly mentioned that each new version must be tested.)\n\n<Point10:1> *True* (The student correctly mentioned Development costs may increase.)\n\n<Point11:1> *True* (The student correctly mentioned that software must be scalable to cope with the increasing number of connected cars.)\n\n<Point12:1> *False* (The students did not explicitly mention that the software must be able to scale without compromising performance.)\n\n<Point13:1> *True* (The student mentioned the need to consider scalability in the development process.)\n\n<Point14:1> *True* (The students correctly pointed out that updating software over the air is more cost effective than service access.)\n\n<Point15:1> *True* (The students correctly mentioned that maintaining software for up to 25 years will increase the overall cost.)","The decision to provide over-the-air software updates for a car over 25 years has several significant implications. Firstly, the development process will need to include long-term support mechanisms. This might mean extending the team's involvement in maintaining and updating the software for the full 25 years. Security is a key concern as well, since network-connected cars are exposed to potential cyber-attacks. This will require substantial investment in security features. Additionally, the software must be thoroughly tested for every update, which could drive up costs. The software also needs to be scalable to accommodate more cars over time. Although over-the-air updates are cheaper than service visits, the long-term commitment to support and security will likely increase overall costs.
<Point1:1> *True* (Students correctly mentioned that the development process needs to include long-term support strategies.)\n\n<Point2:1> *True* (The student correctly mentioned that the development process requires long-term maintenance.)\n\n<Point3:1> *True* (The student correctly mentioned that the team must be prepared to stretch out time to accommodate maintenance and updates.)\n\n<Point4:1> *True* (The student correctly pointed out the problem of security.)\n\n<Point5:1> *True* (The student correctly mentioned the need for investment.)\n\n<Point6:1> *True* (The student specifically mention the need to protect software from malicious attacks.)\n\n<Point7:1> *True* (The student correctly point out that every software update requires rigorous testing.)\n\n<Point8:1> *True* (The student correctly mentioned that rigorous testing is necessary.)\n\n<Point9:1> *True* (The student correctly mentioned that each new version must be tested.)\n\n<Point10:1> *True* (The student correctly mentioned Development costs may increase.)\n\n<Point11:1> *True* (The student correctly mentioned that software must be scalable to cope with the increasing number of connected cars.)\n\n<Point12:1> *False* (The students did not explicitly mention that the software must be able to scale without compromising performance.)\n\n<Point13:1> *True* (The student mentioned the need to consider scalability in the development process.)\n\n<Point14:1> *True* (The students correctly pointed out that updating software over the air is more cost effective than service access.)\n\n<Point15:1> *True* (The students correctly mentioned that maintaining software for up to 25 years will increase the overall cost.)","Developing software that will be updated over the air for 25 years has important implications for both the development process and costs. Firstly, the development team must plan for long-term support, ensuring that updates and patches can be provided for decades. Security is a crucial aspect, as the car will be connected to a network and vulnerable to cyber-attacks, necessitating significant investment in security. Regular testing will be required for each update, adding to the overall development costs. The software must also be designed to scale as more cars are connected. Although over-the-air updates are cheaper than traditional service visits, the long-term maintenance and security costs will likely increase.
<Point1:1> *True* (Students correctly mentioned that the development process needs to include long-term support strategies.)\n\n<Point2:1> *True* (The student correctly mentioned that the development process requires long-term maintenance.)\n\n<Point3:1> *True* (The student correctly mentioned that the team must be prepared to stretch out time to accommodate maintenance and updates.)\n\n<Point4:1> *False* (The student correctly pointed out the problem of security.)\n\n<Point5:1> *True* (The student correctly mentioned the need for investment.)\n\n<Point6:1> *True* (The student specifically mention the need to protect software from malicious attacks.)\n\n<Point7:1> *True* (The student correctly point out that every software update requires rigorous testing.)\n\n<Point8:1> *True* (The student correctly mentioned that rigorous testing is necessary.)\n\n<Point9:1> *True* (The student correctly mentioned that each new version must be tested.)\n\n<Point10:1> *True* (The student correctly mentioned Development costs may increase.)\n\n<Point11:1> *True* (The student correctly mentioned that software must be scalable to cope with the increasing number of connected cars.)\n\n<Point12:1> *False* (The students did not explicitly mention that the software must be able to scale without compromising performance.)\n\n<Point13:1> *True* (The student mentioned the need to consider scalability in the development process.)\n\n<Point14:1> *True* (The students correctly pointed out that updating software over the air is more cost effective than service access.)\n\n<Point15:1> *True* (The students correctly mentioned that maintaining software for up to 25 years will increase the overall cost.)"